# -*- coding: utf-8 -*-
"""PAD_05_ Wizualizacja Danych Zadania demo.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1QxkqIxZxdjFMjtvO7TX_B4vHhhDjC_bA
"""

from google.colab import drive
drive.mount('/content/drive')

!pip install pycountry -q
!pip install pycountry_convert -q

import warnings;   warnings.filterwarnings("ignore")

"""# Wizualizacja Danych

EDA jest skrÃ³tem od **E**xploratory **D**ata **A**nalysis i EDA jest kluczowym etapem poprzedzajÄ…cym stosowanie modelu ML. Jak sama nazwa wskazuje, chodzi o eksploracjÄ™ danych â€” sprawdzenie, czy zestaw danych, nad ktÃ³rym bÄ™dziesz pracowaÄ‡, jest spÃ³jny i nie zawiera brakujÄ…cych wartoÅ›ci. WaÅ¼nym elementem jest takÅ¼e wizualizacja samuych danych aby lepiej przyjrzeÄ‡ siÄ™ ich dystrybucji (rozmieszczeniu) i zachowdzÄ…cym relacjom. 

Warto przy tym zauwaÅ¼yÄ‡, Å¼e nie kaÅ¼dy problem wymaga zastosowania uczenia maszynowego. ByÄ‡ moÅ¼e w pracy zadaniem bÄ™dzie wizualizacja danych w celu analizy i przedstawienia najciekawszych spostrzeÅ¼eÅ„, ktÃ³re ciÄ™zko by byÅ‚o zauwaÅ¼yÄ‡ patrzÄ…Ä‡ na suche dane w tabeli.

Przy formuÅ‚owaniu problemu waÅ¼ne jest postawienie hipotezy. To pomoÅ¼e nam lepiej wybraÄ‡ dane do analizy.
Aby wyjaÅ›niÄ‡, dlaczego jest to konieczne, poniÅ¼szy obraz przedstawia coÅ› znanego jako *Kwartet Ascomebe'a*:

<img src="https://www.researchgate.net/profile/Arch_Woodside2/publication/285672900/figure/fig4/AS:305089983074309@1449750528742/Anscombes-quartet-of-different-XY-plots-of-four-data-sets-having-identical-averages.png">

Å¹rÃ³dÅ‚o: https://www.researchgate.net/publication/285672900_The_general_theory_of_culture_entrepreneurship_innovation_and_quality-of-life_Comparing_nurturing_versus_thwarting_enterprise_start-ups_in_BRIC_Denmark_Germany_and_the_United_States

Kwartet Ascomebe'a jest przykÅ‚adem, dlaczego wizualizacja naszych danych ma ogromne znaczenie. Obraz pokazuje nam, Å¼e statystyki podsumowujÄ…ce (np. Å›rednia, wariancja) dla wszystkich danych sÄ… takie same. Jednak, jak widaÄ‡, rozkÅ‚ady, z ktÃ³rych pochodzÄ… dane, sÄ… szalenie rÃ³Å¼ne. GdybyÅ›my nie wizualizowali naszych danych, nie bylibyÅ›my w stanie w prosty sposÃ³b zidentyfikowaÄ‡ zaleÅ¼noÅ›ci miÄ™dzy danymi.

W tym notatniku przedstawiam uproszczony proces EDA w celach dydaktycznych. 
W rzeczywistoÅ›ci czyszczenie i usuwanie brakujÄ…cych danych podlega parasolowi EDA i bÄ™dzie to cykliczny proces, w ktÃ³rym eksplorujesz swoje dane, identyfikujesz probloemy, czyÅ›cisz je i ponownie eksplorujesz.


BÄ™dziemy pracowaÄ‡ z plikiem â€multiple_choice_responses.csvâ€ z [2019 Kaggle ML & DS Survey](https://www.kaggle.com/c/kaggle-survey-2019/data?select=multiple_choice_responses.csv), ktÃ“ry zawiera 35 pytaÅ„ przeprowadzonych na uÅ¼ytkownikach Kaggle, dotyczÄ…cych stanu nauki o danych i uczenia maszynowego. WedÅ‚ug abstraktu, ankieta ta otrzymaÅ‚a 19 717 uÅ¼ytecznych respondentÃ³w ze 171 krajÃ³w i terytoriÃ³w. JeÅ›li kraj lub terytorium otrzymaÅ‚o mniej niÅ¼ 50 respondentÃ³w, pogrupowaliÅ›my ich w grupÄ™ o nazwie â€Inneâ€ w celu zachowania anonimowoÅ›ci. Zadaniem, ktÃ³re stoi przed nami jest okreÅ›lenie, jakie czynniki majÄ… istotny wpÅ‚yw na rocznÄ… pensjÄ™ osÃ³b w DSML (Data Science i Machine Learning).


"""

## ZaÅ‚aduj dane i wypisz pierwsze wiersze
import pandas as pd
pd.options.display.max_columns = None

path = './drive/MyDrive/PAD_05'
df = pd.read_csv(f"{path}/multiple_choice_responses.csv")
df.head(3)

## Mamy teÅ¼ plik "questions_only.csv". ZaÅ‚aduj go i wczytaj wszystkie pytania
q_df = pd.read_csv(f"{path}/questions_only.csv")
for i, question in enumerate(q_df.iloc[0]):

    print(i, "\t", question)

"""WstÄ™pnie moÅ¼emy zauwaÅ¼yÄ‡, Å¼e:
- Jest wiele pytaÅ„ (duÅ¼o danych do przeanalizowania)
- NiektÃ³re pytania pozwalajÄ… na wiele danych wejÅ›ciowych (pytania wielokrotnego wyboru). W przypadku tych pytaÅ„ nazwy wierszy/kolumn nagÅ‚Ã³wka majÄ… dodany znak `_`, po ktÃ³rym nastÄ™puje jakiÅ› tekst.
  - JeÅ›li tekst to `OTHER_TEXT`, to wydaje siÄ™ wskazywaÄ‡, Å¼e po kategorycznym pytaniu wyÅ›wietlane jest pole tekstowe z opcjÄ… rozwiniÄ™cia dla odbiorcy. WyglÄ…da na to, Å¼e -1 oznacza, Å¼e uÅ¼ytkownik nic nie napisaÅ‚.
  - JeÅ›li tekt to `PART_N`, wÃ³wczas wydaje siÄ™ to byÄ‡ pytaniem wielokrotnego wyboru do zaznaczenia. 
  - Nie wykluczajÄ… siÄ™ wzajemnie

Analiza tych danych kolumna po kolumnie zajmie zbyt wiele czasu. Zamierzamy wiÄ™c zdecydowaÄ‡ o czynnikach, ktÃ³re naszym zdaniem mogÄ… mieÄ‡ wpÅ‚yw na wynagrodzenie, i wyodrÄ™bnimy z listy odpowiednie pytania, ktÃ³re speÅ‚niajÄ… te kryteria. CzÄ™Å›ciowo dlatego nauka o danych jest uwaÅ¼ana za sztukÄ™ â€“ moÅ¼esz mieÄ‡ do czynienia z ogromnym zbiorem danych i nie mieÄ‡ pewnoÅ›ci, od czego zaczÄ…Ä‡ analizÄ™. KorzystajÄ…c ze swojej hipotezy i identyfikujÄ…c, co prÃ³bujesz modelowaÄ‡, musisz uÅ¼yÄ‡ swojej intuicji, co do czynnikÃ³w, ktÃ³re Twoim zdaniem bÄ™dÄ… miaÅ‚y na to duÅ¼y wpÅ‚yw. Dlatego waÅ¼na jest znajomoÅ›Ä‡ dziedziny. Ale im wiÄ™cej eksplorujesz swoje dane z poczÄ…tkowymi koncepcjami, ktÃ³re miaÅ‚eÅ› na myÅ›li, tym wiÄ™cej w koÅ„cu dowiesz siÄ™ o szerszym zbiorze danych.
  
- Salary (target)
- Age
- Gender
- Residence
- Education
- Job role/Experience
- Programming languages
- ML frameworks

Z tej listy wyodrÄ™bnimy nastÄ™pujÄ…ce pytania:
**Q:** 1, 2, 3, 4, 5, 9, **10**, 15, 18, 24, 28.

Jest  kilka innych, ktÃ³re rÃ³wnieÅ¼ byÅ‚yby istotne do analizy - w idealnym Å›wiecie teÅ¼ byÅ›my je analizowali, ale tutaj czas jest ograniczony - i waÅ¼ne jest, aby nauczyÄ‡ CiÄ™ rÃ³Å¼nych technik wizualizacyjnych, jednoczeÅ›nie budujÄ…c intuicjÄ™, na co patrzeÄ‡ w danych.

NiektÃ³re z tych pytaÅ„ obejmujÄ… wiele kolumn w naszej ramce danych. WyodrÄ™bnianie odpowiednich kolumn, ktÃ³re chcemy, nie jest najprostszym zadaniem. PoÅ›wiÄ™Ä‡ trochÄ™ czasu, aby sprÃ³bowaÄ‡ zaimplementowaÄ‡ coÅ›, co zwraca nowÄ… ramkÄ™ danych zawierajÄ…cÄ… odpowiednie kolumny. JeÅ›li po kilku minutach nie masz pewnoÅ›ci, jak postÄ™powaÄ‡, kliknij poniÅ¼ej, aby sprÃ³bowaÄ‡ zaimplementowaÄ‡ metodÄ™, ktÃ³rej ja bym uÅ¼yÅ‚a.


<details>
    <summary><b>Kliknij tutaj, aby zobaczyÄ‡ co bym zrobiÅ‚a</b></summary>
    <ul>
        <li>Zdefiniuj funkcjÄ™, ktÃ³ra iteruje po liÅ›cie integerÃ³w odpowiadajÄ…cyh pytaniom, ktÃ³re chcemy zachowaÄ‡</li>
        <li>Dla kaÅ¼dej iteracji oblicz iloÅ›Ä‡ kolumn od bieÅ¼Ä…cego pytania do nastÄ™pnego pytania w ramce danych (NIE nastÄ™pnego pytania, ktÃ³re chcemy wyodrÄ™bniÄ‡)</li>
        <li>WyodrÄ™bnij/konkatenuj z bieÅ¼Ä…cej pozycji kolumny do bieÅ¼Ä…cej pozycji kolumny + 'odlegÅ‚oÅ›Ä‡' (moÅ¼esz skorzystaÄ‡ z funkcji <code>range()</code>)</li> 
    </ul>
</details>

#### rozwiazanie
"""

idx_to_keep = [1,2,3,4,5,9,10,15,18,24,28]

def extract_columns(df, idx_to_keep):
    
    new_df = pd.DataFrame() # pusty dataframe
    df_col_list = df.columns.tolist()
    
    for i in idx_to_keep:
        column_name_base = "Q{}".format(i)
        column_index = [df_col_list.index(col_name) for col_name in df_col_list if col_name.startswith(column_name_base)][0]
               
        next_column_name_base = "Q{}".format(i+1)
        next_column_index = [df_col_list.index(col_name) for col_name in df_col_list if col_name.startswith(next_column_name_base)][0]
         
        col_idxs_to_extract = range(column_index, next_column_index)
        relevant_cols_df = df.iloc[:, col_idxs_to_extract]
        
        new_df = pd.concat([new_df, relevant_cols_df], axis=1)
        
    return new_df


df_orig = df.copy(deep=True)
df = extract_columns(df_orig, idx_to_keep)
df = df[1:]
df

"""WciÄ…Å¼... duÅ¼o danych... cÃ³Å¼, od czegoÅ› musimy zaczÄ…Ä‡! Arbitralnie zacznijmy od Gender (Q2). Widzimy, Å¼e dane tutaj majÄ… byÄ‡ kategoryczne, wiÄ™c po upewnieniu siÄ™, Å¼e tak jest, wykreÅ›lmy po prostu czÄ™stotliwoÅ›Ä‡ kaÅ¼dej z wartoÅ›ci"""

df["Q2"] = df["Q2"].astype("category")
set(df["Q2"])

"""### HISTOGRAM: 
KorzystajÄ…c z biblioteki plotly narysuj **HISTOGRAM** prezentujÄ…cy rozkÅ‚ad pÅ‚ci.
"""

import plotly.express as px

px.histogram(df, "Q2", labels={"Q2": "Gender"}, title="Counts of Gender")

"""Åšwietnie! A co z miejscami zamieszkania osÃ³b? Ulepszymy wykres i wykreÅ›limy je na mapie Å›wiata, uzupeÅ‚niajÄ…c o liczbÄ… respondentÃ³w z tego kraju (w skali temperatury). Jest to znane jako [mapa choropletowa](https://plotly.com/python/choropleth-maps/), innymi sÅ‚owy kartogram, i wymaga od nas zmiany nazw naszych krajÃ³w na [trzyliterowe kody ISO](https://pl.wikipedia.org/wiki/ISO_3166-1_alfa-3).

PierwszÄ… rzeczÄ…, ktÃ³rÄ… musimy zrobiÄ‡, to spojrzeÄ‡ na samÄ… kolumnÄ™ krajÃ³w (tj. Q3). Po wykonaniu tej czynnoÅ›ci warto zaktualizowaÄ‡ wartoÅ›ci do bardziej konwencjonalnych, jeÅ›li jeszcze ich nie ma.

NastÄ™pnie zaÅ‚adujemy paczkÄ™, do ktÃ³rej bÄ™dziemy mogli przekazaÄ‡ kraj i zwrÃ³cimy nam kod ISO. NastÄ™pnie uÅ¼yjemy nowej kolumny do wykreÅ›lenia naszego kartogramu.
"""

# warto przyjÅ¼eÄ‡ siÄ™ wartoÅ›ciom i zdecydowaÄ‡ czy nie trzeba czegoÅ› poprawiÄ‡
set(df["Q3"])

"""Oto wartoÅ›ci, ktÃ³re moim zdaniem wymagajÄ… aktualizacji:
- Hong Kong (S.A.R.)
- Iran, Islamic Republic of...
- United Kingdom of Great Britain and Northern Ireland
- Viet Nam
- South Korea

ZauwaÅ¼, Å¼e wystÄ™pujÄ… rÃ³wnieÅ¼ "Other"
"""

print("Percentage of 'Other':", df["Q3"].value_counts()["Other"]/len(df) * 100)

values_to_update = {"Q3": 
                    {"Hong Kong (S.A.R.)": "Hong Kong",
                     "Iran, Islamic Republic of...": "Iran",
                     "United Kingdom of Great Britain and Northern Ireland": "United Kingdom",
                     "South Korea": "Republic of Korea",
                     "Viet Nam": "Vietnam"}}

## KorzystajÄ…c z metody replace, zaktualizuj wartoÅ›ci w odpowiedniej kolumnie
# https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.replace.html
df.replace(values_to_update, inplace=True)
set(df["Q3"])

import pycountry

## StwÃ³rz nowy dataframe, ktÃ³ry bÄ™dzie zawieraÅ‚ tylko unikalne wartoÅ›ci countries, ich kody oraz liczbÄ™ instancji danego kraju - BEZ "Other"
countries = df["Q3"][df["Q3"]!= "Other"].unique()
countries_df = pd.DataFrame(countries, columns=["Country"])
countries_df["Count"] = countries_df["Country"].map(df["Q3"].value_counts())

## StwÃ³rz nowÄ… kolumnÄ™, ktÃ³ra bÄ™dzie zawieraÅ‚a kod ISO
country_codes = []
for country in countries_df["Country"]:
    country_code = pycountry.countries.search_fuzzy(country)[0] # Wybierz pierwszy element zwracany przez search (pamiÄ™taj o tym co oznacza pierwszy element dla programisty - index!)
    country_codes.append(country_code.alpha_3)

countries_df["Country Code"] = country_codes
countries_df.head()

px.choropleth(countries_df, locations="Country Code", hover_name="Country", color="Count")

"""A co ze zmiennÄ… gender? Trzeba zgrupowaÄ‡ zmienne razem.

### WYKRES SÅUPKOWY: 
KorzystajÄ…c z biblioteki plotly narysuj wykres sÅ‚upkowy prezentujÄ…cy rozkÅ‚ad pÅ‚ci ale zgrupowany. Dodaj odpowiednie nazwy etykietom: "Q1": "Age", "value": "Count"
"""

age_gender_df = df[["Q1", "Q2"]]
age_gender_groups = age_gender_df.groupby(["Q1", "Q2"]).size().unstack()
fig = px.bar(age_gender_groups, title="Count of Age per Gender", labels={"Q1": "Age", "value": "Count"}) # wykres sÅ‚upkowy
fig.update_layout(legend_title_text='Gender')
# fig.update_layout(barmode="group")
fig.show()

"""Widzimy wiÄ™c, Å¼e najczÄ™stszy wiek pracownikÃ³w DSML to 25-29 lat. WidzÄ™ dwa powody, dla ktÃ³rych te wartoÅ›ci sÄ… znacznie wyÅ¼sze od pozostaÅ‚ych:
1. Data Science i Machine Learning to stosunkowo nowa dyscyplina, a teraz istniejÄ… bezpoÅ›rednie Å›cieÅ¼ki edukacyjne do tych dziedzin, ktÃ³re sÄ… bardziej dostÄ™pne dla mÅ‚odszych ludzi.
2. ZastanÃ³w siÄ™, _skÄ…d_ zebrano dane. Starsi ludzie sÄ… prawdopodobnie mniej skÅ‚onni do korzystania z witryn â€zasobowychâ€, takich jak Kaggle, poniewaÅ¼ 1) nie czujÄ… potrzeby uczenia siÄ™ i 2) mÅ‚odsi ludzie czÄ™Å›ciej pojawiajÄ… siÄ™ w poertalach spoÅ‚ecznoÅ›ciowych.

Do tej pory po prostu tworzyliÅ›my wykresy â€“ byÄ‡ moÅ¼e lepszym planem jest przeprowadzenie nieco bardziej dochodzeniowej analizy kategorii, ktÃ³re wyznaczyliÅ›my wczeÅ›niej. ZrÃ³bmy to z EdukacjÄ….

### ZADANIE 1 (4 pkt):
StwÃ³rz dwa wykresy:
1. Formalne wyksztaÅ‚cenie uczestnikÃ³w (histogram) - kolumna Q4, zamieÅ„ etykietÄ™ label na Education Level, tytuÅ‚ moÅ¼e byÄ‡ Count of Education
2. Formalne wyksztaÅ‚cenie wedÅ‚ug pÅ‚ci. WyÅ›wietl to jako zgrupowany wykres sÅ‚upkowy (wykres sÅ‚upkowy)

1.
"""

fig1 = px.histogram(df, "Q4", labels={"Q4": "Education Level"}, title="Count of Education")
fig1.show()

"""2."""

education_gender_df = df[["Q4", "Q2"]]
education_gender_groups = education_gender_df.groupby(["Q4", "Q2"]).size().unstack()
fig2 = px.bar(education_gender_groups, title="Count of Education per Gender", labels={"Q4": "Education", "value": "Count"}) # wykres sÅ‚upkowy
fig2.update_layout(legend_title_text='Gender')
fig2.show()

"""StwÃ³rzmy kolejny diagram przedstawiajÄ…cy te same informacje, ale na 4 rÃ³Å¼nych wykresach (kolumna Q2 - gender ma byÄ‡ przedstawiona rÃ³Å¼nymi kolorami)"""

fig = px.histogram(df, "Q4", 
                   facet_col="Q2", 
                   color="Q2",
                   title="Counts of Education level per Gender",
                   labels={"Q4": "Education Level"},
                   height=1000, 
                   facet_col_wrap=2, 
                   facet_col_spacing=0.1,
                   )
fig.update_layout(showlegend=False, xaxis={'categoryorder':'total descending'})
fig.update_yaxes(matches=None, showticklabels=True)
# fig.update_xaxes(showticklabels=True)
fig.show()

"""Kilka interesujÄ…cych obserwacji:
1. Ci, ktÃ³rzy zdecydujÄ… siÄ™ na podanie swojej pÅ‚ci opisowo, czÄ™Å›ciej majÄ… stopieÅ„ magistra niÅ¼ licencjata â€“ w porÃ³wnaniu z kaÅ¼dÄ… innÄ… kategoriÄ…, ktÃ³ra czÄ™Å›ciej ma stopieÅ„ licencjata niÅ¼ doktora. ChociaÅ¼ jeÅ›li zanotujemy liczby, zobaczymy, Å¼e pracujemy z liczbami jednocyfrowymi - nie jest to coÅ›, co moÅ¼emy ekstrapolowaÄ‡ statystycznie (przewidzieÄ‡ przebieg danego zjawiska w warunkach nieznanych na podstawie znajomoÅ›ci analogicznego zjawiska w znanych warunkach).
2. Ci, ktÃ³rzy woleli nie podawaÄ‡ swojej pÅ‚ci, woleli rÃ³wnieÅ¼ nie podawaÄ‡ swojego poziomu wyksztaÅ‚cenia (w stosunku do pozostaÅ‚ych kategorii).

Koloejny wykres jest znany jako [Diagram Sankeya](https://en.wikipedia.org/wiki/Sankey_diagram).

NajÅ‚atwiejszym sposobem rozpoczÄ™cia pracy z diagramem Sankeya jest zrozumienie, czego oczekujemy jako kolumny koÅ„cowej. W tym przypadku jako ostatniÄ… kolumnÄ™ uÅ¼yjemy poziomu wyksztaÅ‚cenia. BÄ™dziemy takÅ¼e potrzebowaÄ‡ obliczyÄ‡ ile osÃ³b jest na kaÅ¼dym poziomie edukacji. Aby zaoszczÄ™dziÄ‡ miejsce na diagramie, uogÃ³lnimy niektÃ³re poziomy.

Na tym diagramie Sankeya chcÄ™ zobrazowaÄ‡ drogÄ™ pÅ‚ci, wieku i kraju do poziomu wyksztaÅ‚cenia.
"""

# Chcemy piÄ™ciu poziomÃ³w edukacji: Bachelor's, Master's, Doctoral, Professional, Other
## UtwÃ³rz nowÄ… ramkÄ™ danych z wyksztaÅ‚ceniem ankietowanych, gdzie ich wyksztaÅ‚cenie zostaÅ‚o zmapowane do powyÅ¼szego poziomu
education_df = pd.DataFrame(df["Q4"])
education_df.rename(columns={"Q4": "Education Level"}, inplace=True)

values_to_update = {"Education Level": 
                    {"Some college/university study without earning a bachelorâ€™s degree": "Other",
                     "No formal education past high school": "Other",
                     "I prefer not to answer": "Other"}}

education_df = education_df.replace(values_to_update)
set(education_df["Education Level"])

# UsuÅ„my wartosci na z poziomu edukacji
education_df.isna().sum()
education_df = education_df.dropna(subset=["Education Level"])
education_df.isna().sum()

## Do nowej ramki dodaj kolumny gender, age i region, nazywajÄ…c je w odpowiedniej kolejnoÅ›ci
cols_to_join = ["Q1", "Q2", "Q3"] 
desired_col_names = ["Age", "Gender", "Region"]
for col, name in zip(cols_to_join, desired_col_names):
    education_df[name] = df[col]
    
education_df

# Dla celÃ³w wizualizacyjnych stwÃ³rzmy:
# 1. szersze przedziaÅ‚y wieku, jak 18-29, 30-49, 50-69 oraz 70+
# 2. grupy pÅ‚ci jako "Male", "Female", "Other"
# 3. zamieÅ„my kraje na kontynenty, poza: "India", "United States of America" oraz "Other"

values_to_update = {
    "Age": {"18-21": "18-29", "22-24": "18-29", "25-29": "18-29",
            "30-34": "30-49", "35-39": "30-49", "40-44": "30-49", "45-49": "30-49",
            "50-54": "50-69", "55-59": "50-69", "60-69": "50-69"
           },
    "Gender": {"Prefer not to say": "Other", "Prefer to self-describe": "Other"}
}

education_df = education_df.replace(values_to_update)
education_df

import pycountry_convert as pc
## Mapuj kraje na odpowiednie kontynenty, chyba Å¼e krajem sÄ… Indie, Stany Zjednoczone Ameryki lub inne
countries_to_not_map = ["India", "United States of America", "Other"]
countries_to_map_to_continents = set(education_df["Region"])
for country in countries_to_not_map:
    countries_to_map_to_continents.discard(country)

countries_continent_dict = dict()
for country in countries_to_map_to_continents:
    country_alpha2 = pycountry.countries.search_fuzzy(country)[0].alpha_2
    continent_code = pc.country_alpha2_to_continent_code(country_alpha2)
    continent_name = pc.convert_continent_code_to_continent_name(continent_code)
    countries_continent_dict[country] = continent_name

to_update = {"Region": countries_continent_dict}
education_df = education_df.replace(to_update)
education_df

# Ponowne indeksowanie kolumn w kolejnoÅ›ci, w jakiej chcemy je umieÅ›ciÄ‡ na diagramie, poniewaÅ¼ bÄ™dzie Å‚atwiej z nimi pracowaÄ‡
education_df = education_df.reindex(["Gender", "Age", "Region", "Education Level"], axis=1)

col_names = education_df.columns.tolist()
node_labels = []
num_categorical_vals_per_col = []
for col in col_names:
    uniques = education_df[col].unique().tolist()
    node_labels.extend(uniques)
    num_categorical_vals_per_col.append(len(uniques))
    
node_labels, num_categorical_vals_per_col

"""Ok, wiÄ™c po obejrzeniu diagramu Sankeya wiemy, Å¼e poprzednia kolumna poÅ‚Ä…czy siÄ™ tylko z nastÄ™pnÄ… kolumnÄ…. Parametr `num_categorical_vals_per_col` pozwoli nam dowiedzieÄ‡ siÄ™, ktÃ³re wartoÅ›ci z poprzedniej musimy zmapowaÄ‡ na nastÄ™pne.

Teraz musimy skonstruowaÄ‡ nasz sÅ‚ownik `link`. Jest to nieco mniej proste niÅ¼ powyÅ¼sze. Nasz sÅ‚ownik `link` bÄ™dzie zawieraÅ‚ 3 listy: `source`, `target` i `value`. `source` i `target` wskazujÄ…, ktÃ³re wÄ™zÅ‚y chcemy ze sobÄ… poÅ‚Ä…czyÄ‡, a `value` wskazuje iloÅ›Ä‡, ktÃ³rÄ… chcemy â€wypeÅ‚niÄ‡â€ to poÅ‚Ä…czenie. `source` i `target` to numeryczne indeksy listy `node_labels`, ktÃ³rÄ… utworzyliÅ›my powyÅ¼ej.

Dla kaÅ¼dej kategorii na kolumnÄ™ (kategoria ÅºrÃ³dÅ‚owa) poÅ‚Ä…czymy tÄ™ kategoriÄ™ ze wszystkimi innymi kategoriami nastÄ™pnej kolumny (kategoria docelowa), z rozmiarem, ile kategorii ÅºrÃ³dÅ‚owych jest mapowanych na kategorie docelowe.
"""

education_df.groupby(["Gender", "Age"]).size()["Female"]["18-29"]

import numpy as np
import random

source = []
target = []
value = []
colors = []
for i, num_categories in enumerate(num_categorical_vals_per_col):
    
    if i == len(num_categorical_vals_per_col)-1:
        break
    
    # indeks umoÅ¼liwia nam odwoÅ‚ywanie siÄ™ do kategorii wedÅ‚ug indeksu z listy `node_labels`
    start_index = sum(num_categorical_vals_per_col[:i])
    start_index_next = sum(num_categorical_vals_per_col[:i+1])
    end_index_next = sum(num_categorical_vals_per_col[:i+2])
#     print(start_index, start_index_next, end_index_next)
    
    # moÅ¼e rÃ³wnieÅ¼ daÄ‡ nam kolumnÄ™ kategorii, do ktÃ³rej siÄ™ odwoÅ‚ujemy
    col_name = col_names[i]
    next_col_name = col_names[i+1]
    
    grouped_df = education_df.groupby([col_name, next_col_name]).size()
#     print(grouped_df)
    
    for source_i in range(start_index, start_index_next):
        for target_i in range(start_index_next, end_index_next):
            source.append(source_i)
            target.append(target_i)
            source_label = node_labels[source_i]
            target_label = node_labels[target_i]
            # jeÅ›li indeks nie istnieje w grouped_df, to wartoÅ›Ä‡ wynosi 0
            try:
                value.append(grouped_df[source_label][target_label])
            except:
                value.append(0)
            
            random_color = list(np.random.randint(256, size=3)) + [random.random()]
            random_color_string = ','.join(map(str, random_color))
            colors.append('rgba({})'.format(random_color_string))

print(source)
print(target)
print(value)

link = dict(source=source, target=target, value=value, color=colors)

import plotly.graph_objects as go

fig = go.Figure(data=[go.Sankey(
    node = dict(
      pad = 15,
      thickness = 20,
      line = dict(color = "black", width = 0.5),
      label = node_labels,
      color = "blue"
    ),
    link = link)])

fig.update_layout(title_text="Sankey Diagram (Gender, Age, Region, Education)", font_size=10)
fig.show()

"""### ZADANIE 2 (2 pkt): 
KorzystajÄ…c z biblioteki plotly narysuj **WYKRES FASETOWY** prezentujÄ…cy  liczbÄ™ poziomÃ³w wyksztaÅ‚cenia wg. wieku

Na kaÅ¼dym poziomie majÄ… byÄ‡ widoczne 4 wykresy, wiek to kolumna Q1.
"""

# Posortujemy plik df wedÅ‚ug wieku, aby nasz wykres wyÅ›wietlaÅ‚ siÄ™ w kolejnoÅ›ci wiekowej
df = df.sort_values(by=["Q1"])

fig = px.histogram(df, "Q4", 
                   facet_col="Q1", 
                   color="Q1",
                   title="Counts of Education level per Age",
                   labels={"Q4": "Education Level"},
                   height=2500, 
                   facet_col_wrap=2, 
                   facet_col_spacing=0.1,
                   )
fig.update_layout(showlegend=False, xaxis={'categoryorder':'total descending'})
fig.update_yaxes(matches=None, showticklabels=True)
fig.show()

"""***Wiek***

WczeÅ›niej bardzo szybko przyjrzeliÅ›my siÄ™ wiekowi, ale chciaÅ‚abym dowiedzieÄ‡ siÄ™ wiÄ™cej na jego temat. UÅ¼ywajÄ…c oryginalnego `df`, utwÃ³rz nastÄ™pujÄ…ce wykresy:
1. Wykres fasetowy liczby poziomÃ³w wyksztaÅ‚cenia wedÅ‚ug wieku
2. Aspekty rÃ³Å¼nych rÃ³l wedÅ‚ug wieku

NastÄ™pnie omÃ³wimy nastÄ™pujÄ…ce kwestie:
1. Wykres liczby rÃ³Å¼nych jÄ™zykÃ³w
2. Wykresy podrzÄ™dne/wykres fasetowy liczby rÃ³Å¼nych jÄ™zykÃ³w na wiek
"""



"""Ciekawe! ByÄ‡ moÅ¼e wyniki sÄ… tym, czego byÅ›my siÄ™ spodziewali - osoby w wieku 18-21 lat sÄ… zazwyczaj za mÅ‚ode, aby uzyskaÄ‡ tytuÅ‚y magisterskie, stÄ…d liczba licencjatÃ³w jest dla nich wyÅ¼sza. Jednak w prawie kaÅ¼dej innej grupie wiekowej wyrÃ³Å¼niajÄ… siÄ™ stopnie magisterskie. Co ciekawe, osoby powyÅ¼ej 70. roku Å¼ycia czÄ™Å›ciej majÄ… doktorat ğŸ˜€"""

set(df["Q5"])

fig = px.histogram(df, "Q5", 
             facet_col="Q1",
             color="Q1",
             title="Counts of Education level per Age",
             labels={"Q1": "Age", "Q5": "Job Role"},
             height=2000, 
             facet_col_wrap=2, 
             facet_col_spacing=0.1)

fig.update_layout(showlegend=False)
fig.update_xaxes(showticklabels=True, tickangle=45)
fig.update_yaxes(matches=None, showticklabels=True)

# Nasze dane znajdujÄ… siÄ™ w kolumnach 18_p1, 18_p12
# Naszym pierwszym krokiem bÄ™dzie utworzenie nowej kolumny o nazwie â€Known programming languagesâ€ i utworzenie dla kaÅ¼dego wiersza listy oddzielonej przecinkami zawierajÄ…cej jÄ™zyki programowania, ktÃ³re znajÄ… (oczywiÅ›cie z wyÅ‚Ä…czeniem NaNs)
programming_cols = ["Q18_Part_{}".format(str(i)) for i in range(1, 13)]
programming_df = df[programming_cols]
programming_df.head(5)

programming_col = []
for row in programming_df.itertuples(index=False):
    languages_known = [language for language in row if isinstance(language, str)]
    programming_col.append(",".join(languages_known))
    
programming_df["languages_known"] = programming_col
programming_df

# Przytnijmy nowy df, Å¼eby miaÅ‚ tylko nasz nowy col
programming_df.drop(labels=programming_cols, axis=1, inplace=True)
programming_df

# ZaÅ‚Ã³Å¼, Å¼e spacje oznaczajÄ…, Å¼e nie znajÄ… jÄ™zyka i zamieÅ„ zarÃ³wno spacje, jak i â€Noneâ€ na â€None/NAâ€
values_to_update = {"languages_known": {"": "None/NA", "None": "None/NA"}}
programming_df = programming_df.replace(values_to_update)
programming_df

# UÅ¼yjmy metody get_dummies do stworzenia nowych kolumn
language_dummies = programming_df['languages_known'].str.get_dummies(sep=',')
language_dummies

fig = px.bar(language_dummies.sum(), labels={"index": "Programming Language"}, title="Count of Programming Languages")
fig.update_layout(showlegend=False, xaxis={'categoryorder':'total descending'})
fig.show()

# Dla 4. pobierzmy wiek z oryginalnej ramki danych i poÅ‚Ä…czmy je z tÄ… nowÄ… ramkÄ… danych
ages = df["Q1"]
language_dummies_with_age = language_dummies.join(ages).rename(columns={"Q1": "Age"})
language_dummies_with_age

programming_languages_by_age = language_dummies_with_age.groupby(["Age"]).sum()
px.bar(programming_languages_by_age)
# px.bar(programming_languages_by_age.T)
programming_languages_by_age = programming_languages_by_age.reindex(
    programming_languages_by_age.mean().sort_values().index, axis=1)
programming_languages_by_age = programming_languages_by_age.iloc[:, ::-1]
programming_languages_by_age

programming_languages_by_age_row_norm = programming_languages_by_age.div(programming_languages_by_age.sum(axis=1), axis=0)

"""StwÃ³rzmy wykres z podwykresami, ktÃ³ry bÄ™dzie pokazywaÅ‚ Percent of Known Programming Languages by Age"""

from plotly.subplots import make_subplots

# programming_languages_by_age.index
programming_languages = programming_languages_by_age_row_norm.columns.tolist()
fig = make_subplots(4, 3, subplot_titles=programming_languages_by_age_row_norm.index)
for i, age_range in enumerate(programming_languages_by_age_row_norm.index):
    row = (i // 3) + 1
    col = (i % 3) + 1
    fig.add_trace(
        go.Bar(x=programming_languages, y=programming_languages_by_age_row_norm.iloc[i]),
        row=row, col=col
    )
fig.update_layout(showlegend=False, height=1000, title="Percent of Known Programming Languages by Age")
fig.update_yaxes(tickformat="%")
fig.show()

"""WyglÄ…da na to, Å¼e wszyscy lubiÄ… Pythona! MÅ‚odsi ludzie (ktÃ³rzy najprawdopodobniej robiÄ… licencjat) majÄ… stosunkowo wyÅ¼szy odsetek jÄ™zykÃ³w niÅ¼szego poziomu, takich jak C, C++ i Java. MoÅ¼e to byÄ‡ spowodowane tym, Å¼e muszÄ… uczyÄ‡ siÄ™ tych jÄ™zykÃ³w na uniwersytecie. PoniewaÅ¼ naukowcy zajmujÄ…cy siÄ™ danymi bardziej specjalizujÄ… siÄ™ w swojej karierze, wydajÄ… siÄ™ odchodziÄ‡ od tych jÄ™zykÃ³w do bardziej typowych jÄ™zykÃ³w zwiÄ…zanych z DSML. Grupa 60-69 lat ma wysoki poziom uÅ¼ytkownikÃ³w jÄ™zyka R w porÃ³wnaniu z innymi grupami wiekowymi, podczas gdy wydaje siÄ™, Å¼e wiÄ™kszoÅ›Ä‡ osÃ³b powyÅ¼ej 70. roku Å¼ycia nie zna Å¼adnych jÄ™zykÃ³w programowania.

ByÄ‡ moÅ¼e bardziej przydatne dla nas jest to, jakie jÄ™zyki programowania sÄ… popularne w stosunku do zawodu (P5). StwÃ³rz wykres, ktÃ³ry to pokazuje
"""

## PoÅ‚Ä…cz pytanie o zawÃ³d z ramkÄ… language_dummies
language_dummies_with_job = language_dummies.join(df["Q5"]).rename(columns={"Q5": "Job Title"})
language_dummies_with_job

## Pogrupuj wedÅ‚ug stanowiska i zagreguj liczbÄ™, znormalizuj kaÅ¼dy wiersz i posortuj ramkÄ™ danych wedÅ‚ug Å›redniej z kolumn
languages_job_title_grouped = language_dummies_with_job.groupby(["Job Title"]).sum()
languages_job_title_grouped = languages_job_title_grouped.div(languages_job_title_grouped.sum(axis=1), axis=0)
languages_job_title_grouped = languages_job_title_grouped.reindex(
    languages_job_title_grouped.mean().sort_values().index, axis=1)
languages_job_title_grouped = languages_job_title_grouped.iloc[:, ::-1]
languages_job_title_grouped

"""### ZADANIE 3 (1 pkt):
StwÃ³rz wykres mapy cieplnej powiÄ…zania jÄ™zykÃ³w programowania i nazwy zawodu (job title)
"""

fig3 = px.imshow(languages_job_title_grouped)
fig3.show()

"""### ZADANIE 4 (4 pkt):
StwÃ³rz wykres z podwykresami, ktÃ³ry bÄ™dzie pokazywaÅ‚ Known Programming Language per Job
"""

## StwÃ³rzy wykres danych!
programming_languages = languages_job_title_grouped.columns.tolist()

fig4 = make_subplots(4, 3, subplot_titles=languages_job_title_grouped.index)
for i, age_range in enumerate(languages_job_title_grouped.index):
    row = (i // 3) + 1
    col = (i % 3) + 1
    fig4.add_trace(
        go.Bar(x=programming_languages, y=languages_job_title_grouped.iloc[i]),
        row=row, col=col
    )
fig4.update_layout(showlegend=False, height=1000, title="Percent of Known Programming Languages per Job")
fig4.update_yaxes(tickformat="%")

fig4.show()

"""**Obserwacje**:
- Python jest Å›rednio najpopularniejszym jÄ™zykiem spoÅ›rÃ³d wszystkich stanowisk pracy
- SQL jest najpopularniejszym jÄ™zykiem wÅ›rÃ³d inÅ¼ynierÃ³w baz danych
- MATLAB jest stosunkowo bardziej popularny wÅ›rÃ³d naukowcÃ³w niÅ¼ na innych stanowiskach pracy
- Statystyk woli R od Pythona
- Studenci i inÅ¼ynierowie oprogramowania wolÄ… C++ od R

ZrÃ³bmy jeszcze jeden wykres - mapÄ™ cieplnÄ… frameworka, z ktÃ³rego lubi korzystaÄ‡ kaÅ¼da rola zawodowa
"""

## WykreÅ›l 3 najlepsze frameworki, z ktÃ³rych kaÅ¼da rola lubi korzystaÄ‡
# 28p1 - 28p12
## UtwÃ³rz ramkÄ™ danych, ktÃ³ra zawiera tylko kolumnÄ™ z frameworkiem
framework_cols = ["Q28_Part_{}".format(str(i)) for i in range(1, 13)]
framework_df = df[framework_cols]
framework_df

"""UtwÃ³rz ogÃ³lnÄ… funkcjÄ™ `get_df_for_dummies()`, ktÃ³ra pobiera ramkÄ™ danych, ciÄ…g przedrostka nazwy kolumny oraz gÃ³rny zakres i zwraca ramkÄ™ danych wypeÅ‚nionÄ… zakresem kolumn na podstawie ciÄ…gu przedrostka"""

def get_df_for_dummies(df, prefix_string, end_range, start_range=1):
    ## WSKAZÃ“WKA: skorzystaj z funckji range oraz iteracji aby wygenerowaÄ‡ nazwy kolumn
    dummies_cols = [prefix_string + str(i) for i in range(start_range, end_range)]
    ## WSKAZÃ“WKA: wyciÄ…gnij i zwrÃ³Ä‡ nazwy kolumn z ramki danych
    return df[dummies_cols]

## UtwÃ³rz kolumnÄ™ w tej ramce danych o nazwie â€UÅ¼yte strukturyâ€ i wypeÅ‚nij tÄ™ kolumnÄ™ ramami oddzielonymi przecinkami
framework_col = []
for row in framework_df.itertuples(index=False):
    frameworks_used = [framework for framework in row if isinstance(framework, str)]
    framework_col.append(",".join(frameworks_used))
    
framework_df["frameworks_used"] = framework_col
framework_df

## ZastÄ…p kolumny puste i None wartoÅ›ciami "None/NA"
values_to_update = {"frameworks_used": {"": "None/NA", "None": "None/NA"}}
framework_df = framework_df.replace(values_to_update)
framework_df

"""UtwÃ³rz ogÃ³lnÄ… funkcjÄ™ `get_dummies()`, ktÃ³ra pobiera ramkÄ™ danych i zwraca kolumnÄ™ wypeÅ‚nionÄ… wartoÅ›ciami oddzielonymi przecinkami poszczegÃ³lnych wartoÅ›ci w ramce danych."""

def get_dummies_col(df, sep=","):

    ## zainicjuj pustÄ… listÄ™ do przechowywania kolumny stringÃ³w, ktÃ³ra zostanie uÅ¼yta do utworzenia fikcyjnej ramki danych
    dummies_col = []
    
    ## iteruj po kaÅ¼dym wierszu w ramce danych w sposÃ³b, w ktÃ³ry moÅ¼emy uzyskaÄ‡ dostÄ™p do poszczegÃ³lnych elementÃ³w komÃ³rek
    ## uzyskaj listÄ™ wartoÅ›ci komÃ³rek z wiersza (np. listÄ™ jÄ™zykÃ³w programowania). Upewnij siÄ™, Å¼e nie dodajesz NaNs
    ## poÅ‚Ä…cz je jako ciÄ…g oddzielony przecinkami i doÅ‚Ä…cz go do pustej listy w kolumnie
    for row in df.itertuples(index=False):
        values = [item for item in row if isinstance(item, str)]
        dummies_col.append(sep.join(values))
        
    ## utwÃ³rz nowÄ… kolumnÄ™ w dataframe o nazwie "dummies", ktÃ³ra przyjmuje zawartoÅ›Ä‡ kolumny dummies
    df["dummies"] = dummies_col
    
    ## zamieÅ„ wszystkie "" i "None" z ramki danych na "None/NA"
    values_to_update = {"dummies": {"": "None/NA", "None": "None/NA"}}
    df = df.replace(values_to_update)
    
    ## zwrÃ³Ä‡ nowÄ… ramkÄ™
    return df

## StwÃ³rz ramkÄ™ dla frameworkÃ³w metodÄ… dummies
framework_dummies = framework_df['frameworks_used'].str.get_dummies(sep=',')
framework_dummies

"""StwÃ³rz ogÃ³lnÄ… funkcjÄ™ `dummies_from_series()`, ktÃ³ra pobiera ramkÄ™ danych i argument separatora i zwraca dummies dla Serii"""

def dummies_from_series(series, sep=","):
    ## zwraca dummy ramkÄ™ danych z ramki danych.
    # ZapamiÄ™taj, ktÃ³ra kolumna zostaÅ‚a uÅ¼yta do przypisania ciÄ…gÃ³w, nad ktÃ³rymi chcemy utworzyÄ‡ dummies
    return series["dummies"].str.get_dummies(sep=sep)

## UtwÃ³rz nowÄ… ramkÄ™ danych, ktÃ³ra poÅ‚Ä…czy tÄ™ ramkÄ™ danych z rolami stanowisk
frameworks_for_job_role = framework_dummies.join(df["Q5"]).rename(columns={"Q5": "Job Title"})
frameworks_for_job_role

## Pogrupuj ramkÄ™ danych wedÅ‚ug tytuÅ‚u stanowiska i zagreguj wedÅ‚ug jÄ™zykÃ³w programowania
frameworks_for_job_role_grouped = frameworks_for_job_role.groupby(["Job Title"]).sum()
frameworks_for_job_role_grouped

"""UtwÃ³rz ogÃ³lnÄ… funkcjÄ™ `group_dummies_by()`, ktÃ³ra pobiera ramkÄ™ danych dummies oraz SeriÄ™ i zwraca dummies pogrupowane i zagregowane wedÅ‚ug Serii."""

def group_dummies_by(dummies_df, series):
    series_name = series.name
    to_group = dummies_df.join(series)
    grouped = to_group.groupby([series_name]).sum()
    
    return grouped

framework_df = get_df_for_dummies(df, "Q28_Part_", 13)
framework_df = get_dummies_col(framework_df)
framework_dummies = dummies_from_series(framework_df)
frameworks_for_job_role_grouped = group_dummies_by(framework_dummies, df["Q5"])
frameworks_for_job_role_grouped = frameworks_for_job_role_grouped.div(
    frameworks_for_job_role_grouped.sum(axis=1), axis=0)
frameworks_for_job_role_grouped.index.rename("Job Role", inplace=True)
frameworks_for_job_role_grouped

## UtwÃ³rz mapÄ™ cieplnÄ… powyÅ¼szej ramki danych
px.imshow(frameworks_for_job_role_grouped, title="Heatmap of preferred Frameworks per Job Role")

"""**Obserwacje**:
- None/NA moÅ¼e wprowadzaÄ‡ w bÅ‚Ä…d. Nie zawsze oznacza to, Å¼e ich rola nie wymaga frameworkÃ³w, poniewaÅ¼ obejmuje rÃ³wnieÅ¼ osoby, ktÃ³re byÄ‡ moÅ¼e nie odpowiedziaÅ‚y na pytanie, poniewaÅ¼ ich narzÄ™dzie uÅ¼ytkowania nie byÅ‚o dostÄ™pne jako opcja. Na przykÅ‚ad statystyk moÅ¼e uÅ¼ywaÄ‡ frameworka R, ktÃ³rego opcja nie jest tutaj podana.
- Scikit-learn jest najpopularniejszym wymienionym narzÄ™dziem
- Statystycy czÄ™sto uÅ¼ywajÄ… lasu losowego (Random Forest)

**Roczne wynagrodzenie**

Zacznijmy teraz rozwaÅ¼aÄ‡ naszÄ… zmiennÄ… docelowÄ…! Zaczniemy od od poczÄ…tku. Narysujmy histogram zarobkÃ³w i posortujmy ten wykres w kolejnoÅ›ci zakresÃ³w wynagrodzeÅ„
"""

px.histogram(df, "Q10", labels={"Q10": "Salary"}, title="Count of salary ranges (Unsorted)")

"""WidzÄ™ juÅ¼ z tego kilka interesujÄ…cych ustaleÅ„, ale zanim wspomnÄ™ o czymkolwiek, chcÄ™, abyÅ›my posortowali oÅ› x w kolejnoÅ›ci wartoÅ›ci liczbowej. Oznacza to, Å¼e skrajna lewa kolumna to `0-999 USD`, a skrajna prawa to `> 500 000 USD`.

PoÅ›wiÄ™Ä‡ trochÄ™ czasu na przemyÅ›lenie i wdroÅ¼enie sposobu rozwiÄ…zania tego problemu. JeÅ›li po kilku minutach nie jesteÅ› w stanie wymyÅ›liÄ‡/wymyÅ›liÄ‡ rozwiÄ…zania, przeczytaj i zaimplementuj wg. poniÅ¼szych krokÃ³w.

<details>
<summary><b> Kliknij tutaj, aby wyÅ›wietliÄ‡ moje rozwiÄ…zanie</b></summary>
<ul>
<li>UtwÃ³rz nowÄ… ramkÄ™ danych z samymi pensjami</li>
<li>UtwÃ³rz set wynagrodzeÅ„ (unikalne wartoÅ›ci)</li>
<li>UtwÃ³rz mapowanie kategorii wynagrodzeÅ„ na int, gdzie int to pierwsza numeryczna czÄ™Å›Ä‡ ciÄ…gu (np. <code>{"$0-999": 0, "100,000-124,999": 100000}</code >). Ta czÄ™Å›Ä‡ bÄ™dzie wymagaÅ‚a uÅ¼ycia metod `.replace()` i `.split()` natywnych dla Pythona
<li>ZastÄ…p pensje w ramce danych wartoÅ›ciÄ… caÅ‚kowitÄ…</li>
<li>Posortuj ramkÄ™ danych w rosnÄ…cej kolejnoÅ›ci numerycznej</li>
<li>OdwrÃ³Ä‡ mapowanie i zastÄ…p int ich wariantem ciÄ…gu</li>
<li>WykreÅ›l ramkÄ™ danych i zastÄ…p etykiety x ciÄ…gami wynagrodzeÅ„</li>
</ul>
</details>
"""

salary_df = pd.DataFrame(df["Q10"])
salary_df.rename(columns={"Q10": "Salary"}, inplace=True)
salary_set = set(salary_df["Salary"])
salary_string_int_dict = dict()

for string_salary in salary_set:
    
    if isinstance(string_salary, float): continue
        
    salary = string_salary.replace("$", "").replace("> ", "").replace(",", "")
    salary = salary.split("-")[0]
    salary_string_int_dict[string_salary] = int(salary)

values_to_update = {"Salary": salary_string_int_dict}
salary_df = salary_df.replace(values_to_update)
salary_df = salary_df.sort_values("Salary")

salary_int_string_dict = {v:k for k,v in salary_string_int_dict.items()}
values_to_update = {"Salary": salary_int_string_dict}
salary_df = salary_df.replace(values_to_update)

percent_na = np.round(100 * salary_df["Salary"].isna().sum()/len(salary_df), 2)
print("Percent of users who didn't answer the salary question:", percent_na)
px.histogram(salary_df, "Salary", title="Count of Salary ranges")

"""Prawie 37% uczestnikÃ³w ankiety wprost nie odpowiedziaÅ‚o na to pytanie. Wydaje siÄ™, Å¼e jest dziwnie duÅ¼a liczba ludzi, ktÃ³rzy zarabiajÄ… od \\$0 do \\$999 rocznie. Podejrzewam, Å¼e jest to tak wysokie, poniewaÅ¼ wiele osÃ³b, ktÃ³re nie chciaÅ‚y odpowiedzieÄ‡ na pytanie (i nie zdawaÅ‚y sobie sprawy, Å¼e jest to opcjonalne) zaznaczyÅ‚o to pole. MoÅ¼emy rÃ³wnieÅ¼ zauwaÅ¼yÄ‡ kilka innych interesujÄ…cych faktÃ³w - to znaczy - wydaje siÄ™, Å¼e mamy "dwa" szczyty przy bardzo rÃ³Å¼nych zarobkach - jeden na poziomie 10 000 - 14 999, a drugi na 100 000 - 124 999. Czy moÅ¼esz pomyÅ›leÄ‡, dlaczego tak moÅ¼e byÄ‡? WyglÄ…da teÅ¼ na to, Å¼e jest kilku bardzo bogatych kagglerÃ³w, z ktÃ³rych 83 zarabia ponad $500k rocznie.

Trzy najbardziej popularne grupy zarobkÃ³w (poza 0 - 999) wydajÄ… siÄ™ wynosiÄ‡ 10 000 - 14 999, 100 000 - 124 999 i 30 000 - 39 999. Przygotuj kartogram przedstawiajÄ…cy medianÄ™ wynagrodzeÅ„ w krajach, abyÅ›my mogli lepiej rozrÃ³Å¼niÄ‡, w jakich regionach moÅ¼emy spodziewaÄ‡ siÄ™ zarobkÃ³w
"""

## Przygotuj kartogram przedstawiajÄ…cy medianÄ™ wynagrodzeÅ„ w krajach
median_salaries_df = df[["Q3", "Q10"]]
median_salaries_df.rename(columns={"Q3": "Country", "Q10": "Salary"}, inplace=True)
values_to_update = {"Salary": salary_string_int_dict}
median_salaries_df = median_salaries_df.replace(values_to_update)
median_salaries_df = median_salaries_df.groupby(["Country"]).median()
median_salaries_df

country_codes = []
for country in median_salaries_df.index:
    country_code = pycountry.countries.search_fuzzy(country)[0] # WeÅº pierwszy element zwracany przez przybliÅ¼one wyszukiwanie
    country_codes.append(country_code.alpha_3)

median_salaries_df["Country Code"] = country_codes
median_salaries_df

salaries_series = median_salaries_df["Salary"]
values_to_update = {"Salary": salary_int_string_dict}
median_salaries_df = median_salaries_df.replace(values_to_update)
median_salaries_df["Salary Values"] = salaries_series

px.choropleth(median_salaries_df, locations="Country Code", hover_name=median_salaries_df.index, color="Salary Values", hover_data=["Salary"], title="Median Salaries by Country")

"""BiorÄ…c pod uwagÄ™ liczbÄ™ uczestnikÃ³w z USA i Indii, ktÃ³rÄ… rozpoznaliÅ›my wczeÅ›niej, moÅ¼emy przyjÄ…Ä‡ te wartoÅ›ci, aby byÅ‚y bardziej poprawne w stosunku do rozkÅ‚adu generowania danych niÅ¼ w wiÄ™kszoÅ›ci innych krajÃ³w. DziaÅ‚ajÄ…c przy tym zaÅ‚oÅ¼eniu, wyglÄ…da na to, Å¼e w USA i Szwajcarii rozsÄ…dnie byÅ‚oby byÄ‡ na 100 000+, podczas gdy w Indiach najprawdopodobniej zarabialiby coÅ› w przedziale 7500 - 9999. WyglÄ…da na to, Å¼e Australia teÅ¼ ma kilka dobrze pÅ‚atnych miejsc pracy. SpodziewalibyÅ›my siÄ™, Å¼e Å›rednia pensja w Wielkiej Brytanii bÄ™dzie wyÅ¼sza niÅ¼ 10 000 - 14 999. Jakie rzeczy moglibyÅ›my zbadaÄ‡, aby okreÅ›liÄ‡, dlaczego ta wartoÅ›Ä‡ wynagrodzenia jest niÅ¼sza, niÅ¼ siÄ™ spodziewamy?

A co z wynagrodzeniami wedÅ‚ug pÅ‚ci?
"""

salaries_by_gender_df = df[["Q2", "Q10"]]
salaries_by_gender_df.rename(columns={"Q2": "Gender", "Q10": "Salary"}, inplace=True)
values_to_update = {"Salary": salary_string_int_dict}
salaries_by_gender_df = salaries_by_gender_df.replace(values_to_update)
salaries_by_gender_df

"""StwÃ³rzmy wykres pudeÅ‚kowy salary per gender"""

px.box(salaries_by_gender_df, "Gender", "Salary", labels={"Salary": "Salary (Lower Bound)"}, title="Boxplot of Salary per Gender")

"""ChociaÅ¼ wyglÄ…da na to, Å¼e ktÃ³rakolwiek z kategorii jest w stanie osiÄ…gnÄ…Ä‡ najwyÅ¼szy przedziaÅ‚ zarobkÃ³w, wydaje siÄ™, Å¼e kobiety majÄ… najniÅ¼szÄ… medianÄ™ zarobkÃ³w. Wydaje siÄ™, Å¼e ci, ktÃ³rzy wolÄ… opisywaÄ‡ siebie, majÄ… rÃ³wnieÅ¼ wyÅ¼sze Å›rednie zarobki.

Jakie sÄ… najlepiej pÅ‚atne prace? WykreÅ›lmy Å›redniÄ… pensjÄ™ kaÅ¼dej roli
"""

salaries_job_df = df[["Q5", "Q10"]]
salaries_job_df.rename(columns={"Q5": "Job Title", "Q10": "Salary"}, inplace=True)

values_to_update = {"Salary": salary_string_int_dict}
salaries_job_df = salaries_job_df.replace(values_to_update)
salaries_job_df

# salary_series = salaries_job_df["Salary"]
# salaries_job_df["Salary Bracket"] = salary_series
# salaries_job_df

grouped_mean_salaries = salaries_job_df.groupby(["Job Title"]).mean().reset_index().sort_values(by="Salary", ascending=False)
grouped_mean_salaries.dropna(inplace=True)
px.bar(grouped_mean_salaries, "Job Title", "Salary", labels={"Salary": "Mean Salary"}, title="Mean Salary per Job Role")

"""Jaki moÅ¼e byÄ‡ moÅ¼e bardziej informacyjny sposÃ³b przedstawienia tych wynagrodzeÅ„? MyÅ›lÄ™ o wykresie pudeÅ‚kowym. OdrzuÄ‡my pensje NA i â€0â€ i zwizualizujmy to

### ZADANIE 5 (1 pkt):
StwÃ³rz wykres pudeÅ‚kowy dla wynagrodzeÅ„.
"""

salaries_job_df.dropna(inplace=True)

fig5 = px.box(salaries_job_df, "Job Title", "Salary", labels={"Salary": "Salary (Lower Bound)"}, title="Boxplot of Salary per Gender")
fig5.show()

"""**Obserwacje**:
- Ankieta wydaje siÄ™ wskazywaÄ‡, Å¼e wszystkie role zawodowe majÄ… potencjaÅ‚ do zdobycia pracy za \\$500k+ poza pracÄ… inÅ¼yniera bazy danych
- Na caÅ‚ym Å›wiecie inÅ¼ynierowie oprogramowania i analitycy danych majÄ… dwie najniÅ¼sze Å›rednie pensje - przy czym inÅ¼ynier oprogramowania ma niÅ¼szÄ… medianÄ™ wynagrodzenia niÅ¼ analityk danych, ale wyÅ¼szÄ… Å›redniÄ… (jak widaÄ‡ na pierwszym wykresie)
- ZarzÄ…dzanie produktami/projektami i Data Science ğŸ˜‰ wydajÄ… siÄ™ byÄ‡ najbardziej lukratywnymi stanowiskami pracy - przy czym ta pierwsza nieznacznie przejmuje inicjatywÄ™

ZastanÃ³wmy sie, jaki jest procent data scientists, ktÃ³rzy zarabiajÄ… powyÅ¼ej \\500 tys. USD w porÃ³wnaniu z kierownikami projektÃ³w:
"""

num_data_scientists_above_500 = len(salaries_job_df[(salaries_job_df["Job Title"] == "Data Scientist") & (salaries_job_df["Salary"] == 500000)])
num_project_managers_above_500 = len(salaries_job_df[(salaries_job_df["Job Title"] == "Product/Project Manager") & (salaries_job_df["Salary"] == 500000)])

percent_ds_above_500 = 100 * num_data_scientists_above_500/len(salaries_job_df)
percent_pm_above_500 = 100 * num_project_managers_above_500/len(salaries_job_df)

print("The percent of Data Scientists who earn above $500,000: {}%".format(np.round(percent_ds_above_500, 2)))
print("The percent of Project Managers who earn above $500,000: {}%".format(np.round(percent_pm_above_500, 2)))

"""Zobaczmy, jaki wpÅ‚yw majÄ… lata programowania (Q11) na wynagrodzenia"""

programming_experience_salary_df = df[["Q10", "Q15"]]
programming_experience_salary_df.rename(columns={"Q10": "Salary", "Q15": "Programming Experience"}, inplace=True)
values_to_update = {"Salary": salary_string_int_dict}
programming_experience_salary_df = programming_experience_salary_df.replace(values_to_update)
programming_experience_salary_df

category_array = ["I have never written code", "< 1 years", "1-2 years", "3-5 years", "5-10 years", "10-20 years", "20+ years"]
# fig = px.scatter(programming_experience_salary_df, "Programming Experience", "Salary", title="Density of Programming Experience vs Salary")
fig = px.scatter(programming_experience_salary_df, "Programming Experience", "Salary", facet_col=df["Q2"],title="Density of Programming Experience vs Salary")
fig.update_traces(marker=dict(
            opacity=0.05,
            size=20,
            line=dict(
                color='MediumPurple',
                width=0.5
            )))
fig.update_layout(xaxis={'categoryorder':'array', 'categoryarray':category_array})
fig.show()

"""**Obserwacje**:
- SÄ… ludzie zarabiajÄ…cy \\$500k+, ktÃ³rzy nigdy nie napisali kodu. To samo z ludÅºmi, ktÃ³rzy majÄ… mniej niÅ¼ rok doÅ›wiadczenia w programowaniu.
- Istnieje jednak trend, w ktÃ³rym bardziej doÅ›wiadczeni programiÅ›ci zarabiajÄ… wyÅ¼sze wynagrodzenie na wszystkich poziomach wynagrodzeÅ„
- Nie ma zbyt wielu doÅ›wiadczonych kobiet (tj. ponad 10-20 lat doÅ›wiadczenia)

Teraz narysujemy kolejny diagram Sankeya â€“ tym razem Å›ledzÄ…cy, w jaki sposÃ³b pÅ‚eÄ‡, wiek, stopieÅ„ naukowy, rola i kraj wpÅ‚ywajÄ… na twojÄ… pensjÄ™. Aby to osiÄ…gnÄ…Ä‡, uogÃ³lnij kod, ktÃ³ry napisaÅ‚am wczeÅ›niej dla diagramu Sankeya, do funkcji `get_sankey_data`, ktÃ³ra jako argument pobiera ponownie zindeksowanÄ… ramkÄ™ danych i zwraca node_labels oraz sÅ‚ownik `link`. NastÄ™pnie uÅ¼yj tych elementÃ³w, aby wykreÅ›liÄ‡ diagram Sankeya

### *ZADANIE 7 (10 pkt):
Zadanie dla chÄ™tnych, na dodatkowe punkty
StwÃ³rzy wykres z podwykresami, ktÃ³ry bÄ™dzie pokazywaÅ‚ Percent of Known Programming Languages by Age
Teraz narysujemy kolejny diagram Sankeya â€“ tym razem Å›ledzÄ…cy, w jaki sposÃ³b pÅ‚eÄ‡, wiek, stopieÅ„ naukowy, rola i kraj wpÅ‚ywajÄ… na twojÄ… pensjÄ™. Aby to osiÄ…gnÄ…Ä‡, uogÃ³lnij kod, ktÃ³ry napisaÅ‚am wczeÅ›niej dla diagramu Sankeya, do funkcji `get_sankey_data`, ktÃ³ra jako argument pobiera ponownie zindeksowanÄ… ramkÄ™ danych i zwraca node_labels oraz sÅ‚ownik `link`. NastÄ™pnie uÅ¼yj tych elementÃ³w, aby wykreÅ›liÄ‡ diagram Sankeya
"""

## Wykorzystaj ponownie kod do Sankeya

## utwÃ³rz nowÄ… ramkÄ™ danych z odpowiednimi zmiennymi, za pomocÄ… ktÃ³rych chcemy wykreÅ›liÄ‡ naszego Sankeya, ponownie zindeksuj go i przekaÅ¼ do funkcji get_sankey_data

fig.show()

"""PowyÅ¼szy schemat jest chaotyczny, uporzÄ…dkujmy go w nastÄ™pujÄ…cy sposÃ³b:
- Pogrupuj kraje wedÅ‚ug kontynentÃ³w (znowu nie zmienimy Indii i USA)
- StwÃ³rz szersze przedziaÅ‚y na pensjÄ™ (moÅ¼e 5 przedziaÅ‚Ã³w?), usuwajÄ…c \\$0-999
- Dodaj doÅ›wiadczenie w programowaniu jako kolumnÄ™ na powyÅ¼szym wykresie
"""

## ZamieÅ„ kraje na kontynenty
values_to_update = {"Country": countries_continent_dict}
salaries_sankey_df = salaries_sankey_df.replace(values_to_update)
salaries_sankey_df

## UsuÅ„ wiersze z pensjÄ… $0-999 oraz zwiÄ™ksz przedziaÅ‚y pensji
set(salaries_sankey_df["Salary"])
salaries_sankey_df = salaries_sankey_df[salaries_sankey_df["Salary"] != "$0-999"]
under_30000, under_80000, under_150000, under_300000, under_500000 = "0 - 29,999", "30,000 - 79,999", "80,000 - 149,999", "150,000 - 299,999", "300,000 - 500,000" 
salary_wider_bins_dict = dict()
for salary_string in set(salaries_sankey_df["Salary"]):
    
    if salary_string == "> $500,000" or isinstance(salary_string, float):
        continue
    
    salary_upper_bound = salary_string.split("-")[-1]
    salary_upper_bound = salary_upper_bound.replace(",", "")
    salary_upper_bound = int(salary_upper_bound)
    
    if salary_upper_bound < 30000:
        salary_wider_bins_dict[salary_string] = under_30000
    elif salary_upper_bound < 80000:
        salary_wider_bins_dict[salary_string] = under_80000
    elif salary_upper_bound < 150000:
        salary_wider_bins_dict[salary_string] = under_150000
    elif salary_upper_bound < 300000:
        salary_wider_bins_dict[salary_string] = under_300000
    elif salary_upper_bound < 500000:
        salary_wider_bins_dict[salary_string] = under_500000

values_to_update = {"Salary": salary_wider_bins_dict}
salaries_sankey_df = salaries_sankey_df.replace(values_to_update)
salaries_sankey_df

## UtwÃ³rz nowÄ… kolumnÄ™ w salaries_sankey_df, ktÃ³ra jest dÅ‚ugoÅ›ciÄ… doÅ›wiadczenia w programowaniu
salaries_sankey_df["Programming Experience"] = df["Q15"]
salaries_sankey_df

## ZmieÅ„ indeks i wy Å›wietl wykres Sankeya
# UsuÅ„ kolumny Age i Gender ci zmieÅ„ indeksy ramki na:
# Role, Programming Experience, Region, Education, Salary
salaries_sankey_df = salaries_sankey_df.rename(columns={"Country": "Region"})
salaries_sankey_df = salaries_sankey_df.reindex(["Role", "Programming Experience", "Region", "Education", "Salary"], axis=1)
node_labels, link = get_sankey_data(salaries_sankey_df)
fig = go.Figure(data=[go.Sankey(
    node = dict(
      pad = 15,
      thickness = 20,
      line = dict(color = "black", width = 0.5),
      label = node_labels,
      color = "blue"
    ),
    link = link)])

fig.update_layout(title_text="Sankey Diagram (Role, Programming Experience, Region, Education, Salary)", font_size=10, height=800)
fig.show()

"""Informacje i Å›cieÅ¼ki do rÃ³Å¼nych przedziaÅ‚Ã³w wynagrodzeÅ„ stajÄ… siÄ™ teraz znacznie bardziej zrozumiaÅ‚e do interpretacji. NiektÃ³re interesujÄ…ce odkrycia, ktÃ³re znalazÅ‚am na tym wykresie, to fakt, Å¼e jest kilku inÅ¼ynierÃ³w oprogramowania i naukowcÃ³w zajmujÄ…cych siÄ™ danymi, ktÃ³rzy nigdy wczeÅ›niej nie pisali kodu - nie jestem przekonana, czy to prawda, ale jest ich niewielu, wiÄ™c moglibyÅ›my to przyjÄ…Ä‡ jako obserwacje odstajÄ…ce. WiÄ™kszoÅ›Ä‡ osÃ³b zarabiajÄ…cych powyÅ¼ej 150 000 wydaje siÄ™ mieÄ‡ stopieÅ„ magistra lub doktora. Zabawa z kolejnoÅ›ciÄ… indeksowania moÅ¼e szybko umoÅ¼liwiÄ‡ wyciÄ…gniÄ™cie wnioskÃ³w z rÃ³Å¼nych kombinacji kolumn (np. umieszczajÄ…c Education przed Job title, moÅ¼emy zobaczyÄ‡, w jakie role obejmÄ… ludzie, na podstawie ich wyksztaÅ‚cenia).

Ostatni wykres dla pytania 9, ktÃ³re dotyczy umiejÄ™tnoÅ›ci i obowiÄ…zkÃ³w zwiÄ…zanych z ich obecnÄ… pracÄ…. UtwÃ³rz poboczne wykresy tych umiejÄ™tnoÅ›ci, zagregowane, dla kaÅ¼dego przedziaÅ‚u wynagrodzeÅ„. UÅ¼yj 6 przedziaÅ‚Ã³w wynagrodzeÅ„, ktÃ³re zdefiniowaliÅ›my wczeÅ›niej. Upewnij siÄ™, Å¼e kolumny tworzonej ramki danych skills sÄ… nienaruszone i zademonstruj swÃ³j wykres/i wszelkie inne dane wyjÅ›ciowe Pythona w zrozumiaÅ‚y sposÃ³b. 
"""

skills_df = get_df_for_dummies(df, "Q9_Part_", 9)
skills_df = get_dummies_col(skills_df, sep="::")
skills_dummies = dummies_from_series(skills_df, sep="::")
skills_grouped = group_dummies_by(skills_dummies, salaries_sankey_df["Salary"])
skills_grouped = skills_grouped.reindex(["0 - 29,999", "30,000 - 79,999", "80,000 - 149,999", "150,000 - 299,999", "300,000-500,000", "> $500,000"])
skills_grouped

skills_df_columns = skills_grouped.columns
skills_df_columns_mapping = {col: i for i, col in enumerate(skills_df_columns)}
skills_grouped = skills_grouped.rename(columns=skills_df_columns_mapping)
[print(i, "\t", col) for col, i in skills_df_columns_mapping.items()]
print()

## StwÃ³rz wykresy. OÅ› x powinna byÄ‡ 4 najlepszymi jÄ™zykami programowania, a oÅ› y ich liczbÄ….
fig = make_subplots(2, 3, subplot_titles=skills_grouped.index)
for i, role in enumerate(skills_grouped.index):
    row = (i // 3) + 1
    col = (i % 3) + 1
    skills_values = skills_grouped.iloc[i]
    fig.add_trace(
        go.Bar(x=skills_values.index, y=skills_values),
        row=row, col=col
    )
    fig.update_xaxes(type="category")
fig.update_layout(showlegend=False, height=800, title="Skills/Responsibilities per Salary Bracket")
fig.show()

"""**Obserwacje:**
- We wszystkich przedziaÅ‚ach wynagrodzeÅ„ obecne jest 0 -â€Analyze and understand data to influence product or business decisionsâ€.
- OprÃ³cz najniÅ¼szego i najwyÅ¼szego przedziaÅ‚u, wyglÄ…da na to, Å¼e wiele zadaÅ„ obejmuje 3 - "Builing prototypes which explores applying machine learning to new area".
- Dwa gÃ³rne przedziaÅ‚y wynagrodzeÅ„ majÄ… wyÅ¼szÄ… wzglÄ™dnÄ… czÄ™stotliwoÅ›Ä‡ odpowiedzi 4 - "Do research that advances the state of the art of machine learning".
- Wydaje siÄ™, Å¼e w ostatnich trzech nawiasach wyÅ¼szy odsetek pracownikÃ³w ma odpowiedzialnoÅ›Ä‡ za opcjÄ™ 5 - "Experimentation and iteration to improve existing ML models".
- Opcja 7 - "None/NA" - wydaje siÄ™ byÄ‡ bardziej rozpowszechniona w dwÃ³ch dolnych nawiasach i najwyÅ¼szym nawiasie. Podejrzewam, Å¼e powodem tego jest to, Å¼e Å¼aden z opisÃ³w stanowisk nie odnosi siÄ™ do tych osÃ³b, podczas gdy pozostaÅ‚e trzy przedziaÅ‚y majÄ… obowiÄ…zki skoncentrowane bardziej na data science i uczeniu maszynowym.

Jaki rodzaj wykresu mÃ³gÅ‚ pokazaÄ‡ te informacje w bardziej przejrzysty i zwiÄ™zÅ‚y sposÃ³b?
"""